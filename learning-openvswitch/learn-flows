好的，理解了。让我们深入学习 Open vSwitch 中更复杂的流表规则。流表是 OVS 的核心，它可以让你精确控制数据包的转发行为。下面我将为你详细介绍几种常见的流规则类型，并提供具体的命令示例，让你能在 WSL 中动手实践。

-----

### 1\. 基于入端口的转发

这是最基础的流规则，根据数据包进入 OVS 的端口来决定如何处理。你可以用它来模拟一个简单的防火墙，只允许某些端口的流量通过。

**场景**：假设你的 OVS 网桥 `br0` 有两个端口 `veth-ovs1` 和 `veth-ovs2`。你想让 `veth-ovs1` 端口上的所有流量都转发到 `veth-ovs2`，反之亦然。这其实就是最基本的二层交换机行为，但我们可以用流表来明确地定义它。

**命令示例**：

首先，确保你已经创建了 `br0` 网桥，并且将 `veth-ovs1` 和 `veth-ovs2` 添加了进来。

```bash
# 清除之前的流规则，从一个干净的状态开始
sudo ovs-ofctl del-flows br0

# 定义流规则：
# 1. 优先级为100。
# 2. 匹配入端口为 veth-ovs1 (port=1) 的所有数据包。
# 3. 动作是转发到 veth-ovs2 (port=2)。
sudo ovs-ofctl add-flow br0 "priority=100,in_port=1,actions=output:2"

# 4. 匹配入端口为 veth-ovs2 (port=2) 的所有数据包。
# 5. 动作是转发到 veth-ovs1 (port=1)。
sudo ovs-ofctl add-flow br0 "priority=100,in_port=2,actions=output:1"

# 查看流表，你会看到你添加的两条规则
sudo ovs-ofctl dump-flows br0
```

-----

### 2\. 基于二层（L2）信息的转发

这类流规则根据数据包的 **MAC 地址** 来进行匹配。你可以用它来阻止特定 MAC 地址的设备通信，或者将特定设备的数据包转发到指定端口。

**场景**：假设你想阻止一个 MAC 地址为 `0a:00:27:00:00:01` 的设备访问网络。

**命令示例**：

首先，我们添加一条默认的允许所有流量的规则，然后添加一条更高优先级的规则来阻止特定的 MAC 地址。

```bash
# 清除流规则
sudo ovs-ofctl del-flows br0

# 添加一条低优先级的规则，允许所有流量在端口间互传（二层交换机行为）
sudo ovs-ofctl add-flow br0 "priority=1,actions=normal"

# 添加一条高优先级的规则，匹配源 MAC 地址为 0a:00:27:00:00:01 的数据包
# 动作是丢弃 (drop)
sudo ovs-ofctl add-flow br0 "priority=100,dl_src=0a:00:27:00:00:01,actions=drop"

# 查看流表
sudo ovs-ofctl dump-flows br0
```

这样，任何从这个 MAC 地址发出的数据包都会被 OVS 丢弃。

-----

### 3\. 基于三层（L3）和四层（L4）信息的转发

这是最常用的流规则类型之一，可以根据 **IP 地址**、**协议类型**（TCP、UDP、ICMP）以及 **端口号** 来精确控制流量。你可以用它来实现一个功能强大的虚拟防火墙。

**场景**：你想阻止 `192.168.1.10` 这个 IP 地址对 `192.168.1.20` 进行 `ping`（ICMP 协议），但允许其他所有流量通过。

**命令示例**：

```bash
# 清除流规则
sudo ovs-ofctl del-flows br0

# 添加一条低优先级的规则，允许所有流量通过
sudo ovs-ofctl add-flow br0 "priority=1,actions=normal"

# 添加一条高优先级的规则，匹配源IP为192.168.1.10，目的IP为192.168.1.20，且协议为ICMP的数据包
# 动作是丢弃 (drop)
sudo ovs-ofctl add-flow br0 "priority=100,ip,nw_src=192.168.1.10,nw_dst=192.168.1.20,nw_proto=1,actions=drop"
```

这里的 `nw_proto=1` 表示 **ICMP** 协议。如果你想阻止 TCP 流量，可以将 `nw_proto` 设置为 `6`，UDP 为 `17`。

**更精细的控制**：

如果你只想阻止 `192.168.1.10` 访问 `192.168.1.20` 的 **80 端口** (HTTP)，你可以这样做：

```bash
# 清除流规则
sudo ovs-ofctl del-flows br0

# 允许所有流量
sudo ovs-ofctl add-flow br0 "priority=1,actions=normal"

# 添加规则：匹配TCP协议，源IP 192.168.1.10，目的IP 192.168.1.20，目的端口为80
# 动作是丢弃
sudo ovs-ofctl add-flow br0 "priority=100,ip,tcp,nw_src=192.168.1.10,nw_dst=192.168.1.20,tp_dst=80,actions=drop"
```

-----

### 4\. 更多动作类型

除了 `output` 和 `drop`，OVS 流表还支持许多其他有用的动作。

**场景**：你想将所有从 `veth-ovs1` 进来的数据包的源 MAC 地址修改为 `0a:00:27:00:00:02`，然后再转发到 `veth-ovs2`。这在某些网络功能虚拟化 (NFV) 场景中非常有用。

**命令示例**：

```bash
# 清除流规则
sudo ovs-ofctl del-flows br0

# 匹配入端口为1的数据包
# 动作是：
# 1. 设置源 MAC 地址为 0a:00:27:00:00:02 (set_field:0a:00:27:00:00:02->eth_src)
# 2. 转发到端口2 (output:2)
sudo ovs-ofctl add-flow br0 "in_port=1,actions=set_field:0a:00:27:00:00:02->eth_src,output:2"
```

通过这些具体的例子，你应该能更好地理解 Open vSwitch 流表的强大之处。它们就像一个个“编程”规则，让你能根据数据包的任何字段来定义其在网络中的命运。

下一步，你可以尝试将这些规则组合起来，例如，只允许特定 IP 地址的设备访问特定的端口，并阻止其他所有流量。如果你在实践中遇到任何问题，随时可以提问。
